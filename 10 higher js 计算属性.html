<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    // JS是代码执行分两个阶段：
    // 1，预编译两个作用  变量提升 函数提升
    // 2，执行

    // 数据的存储
    // 五大区
    // 1.栈区 2 堆区 3.BSS段 4.常量区/数据段  5代码段
    // 重点关注 堆区 栈区
    // 基本数据类型存在栈区 number boolean string null undefined object
    // 对象存在堆区 array function date RegExp
    //  JS中有两类数据类型：
    //  1，基本数据类型
    //  5个： 数值，字符串，布尔，undefined, null
    //  2，引用数据类型
    //  对象：object
    //  函数：function
    //  数组：Array

// 判断数据类型 typeof
//     var a = 1;
    // console.log(typeof a);//number
    // var c = null;
    // console.log(typeof c);//object

    //typeof 判断六种数据类型
    // number string boolean undefined object function

    // 2，基本数据类型的存储与赋值

    // var a = 10;
    // var b = a;
    // console.log(a, b);
    // b = 100;
    // console.log(a, b);
    // 赋值：
    // var a = 10;   var b = a;
    // 上面的代码可以这样理解：将a对应的内存中的值取出来复制了一份，给了b
    // 注意：复制后给了b后，此时a和b对应的内存空间是彼此独立，互不影响，
    // 无论你去修改谁，都不是影响另一个。

    // 存储
    // var a = [1,3];
    // var b = a;
    // console.log(a, b);
    // b[0] = 110;
    // console.log(a, b);

    // 栈区                                              堆区
    // a 堆区的地址 （第1，2行 第二行代码执行后）             【1，2】
    // b 堆区的地址                                      【110，2】第四行代码执行后替换
    // 把a中在栈区存储的地址赋给b, 此时，a和b指向了同一个堆区中的数据。
    // 所以你对a,或b的修改，势必要影响另一个。


    // 4，深入理解 == 与 ===
    // 对于基本数据类型的
    // a == b
    // 先判断a,b的数据类型，如果数据类型一致，直接比较它们保存在栈区的值。
    // 如果类型不致，先进行数据类型的转换，然后在比较。

    // a === b
    // 先判断数据类型是否一致，不一致，就直接返回false,
    // 如果一致，再判断值，相同	返回true, 不同返回false


    // 对于引用数据类型的
    // a == b
    // 没有类型比较这一步，因为它们都是同一个类型，叫引用类型，
    // 直接判断保存在栈区的值，栈区的值是指向堆区数据的地址，然后判断这两个地址是否一致。

    // 当你想比较两个值时，最好怎么做？
    // 最好习惯：
    // 1，使用 ===
    // 2，把字面量写在左边

    // 3，预编译做两件事：
    // 一个是扫描代码段看看有没有错误。
    // 二提升。

    // 4，变量提升：var声明的全局变量是提升的，
    // for循环中的带var变量也是提升了，函数内部的带var变量提升了， 遗漏声明的变量是没有提升。

    // 函数目前我们分两种：函数声明和函数表达式， 函数声明会提升，函数表达式不会提升。

    // 6，js代码以代码段为单位，从上到下顺序执行，事件会改变代码的执行顺序。
    // 8, 基本数据类型直接将数据保存在栈区，
    // 引用数据类型的真正数据是保存在堆区的，在栈区保存着引用数据类型数据的地址。

    // 变量深入
    // var 与 不加 var的区别
    // 加var的可以做局部变量也可以做全局变量，没有var只能做全局变量

    // var a = 1;//全局
    // function f() {
    //     var b = 2;//局部
    // }
    //
    // console.log(a);//全局
    // console.log(b);//局部

    // 再看一个，没有var的变量是一个全局变量，在函数外面是可以访问的。
    // var a = 1;//全局
    // function f1() {
    //     b = 2 //全局 不加var 相当于一个全局变量 在函数外面也可以访问到
    // }
    // f();
    // console.log(a);
    // console.log(b);

    // 再再看一个，在函数内部中的全局变量，要想让它起作用，需要调用这个函数。
    // var a = 1;//全局
    // function f() {
    //     b = 2;//全局
    // }
    //
    // console.log(a);
    // console.log(b);
    //函数没有被调用 所以b 变量就相当于不存在


    // 是否可以被删除， 加var的不能被删除，没有var的可以被删除
    // var a = 1;
    // b = 2;
    // console.log(a);
    // console.log(b);
    // delete a;
    // delete b;


    // 加var的可以提升，没有var的不能提升。
    // console.log(a);
    // console.log(b);
    // var a = 1;
    // b = 2;


    // 2，变量的作用域？
    // 在JS中变量的作用域只有两个，一个是全局作用域，
    // 一个是局部作用域，在JS中没有块级作用域。

    // (1)一般认为在函数的外部就是一个全局作用域
   // var a = 1; //全局
   //  function f() {
   //      var b = 3;//b 处于局部作用域
   //  }
   //
   //  console.log(a);
   //  console.log(b);

    // 全局作用域不能去访问局部作用域
    // (2)局部作用域
    // var a = 1;//a全局作用域
    // function f4() {
    //     var b = 3;//b 局部作用域
    //     console.log(a);
    // }
    // f4();
    // 局部作用域可以去访问全局作用域


    // （3）在JS中没有块级作用域
    // for (var i = 0; i < 10; i++){
    //     var a =34;
    // }
    // console.log(a);
    //在其他编程语言中{}会创建块级作用域 js中{}不能划分作用域 能划分的只有函数

    // 变量的就近使用原则
    // var a = 1;
    // function f() {
    //     var a;//在函数内部如果有和外部名称一样的变量 以局部的为准 也就是就近原则为
    //     console.log(a);
    //     a = 2;
    //     console.log(a);
    // }
    // f();
    // console.log(a);//因为函数内部是一个局部变量 在外面访问不到 所以他就去访问了全局的a

    // var a = 1;
    // function f() {
    //     console.log(a);//1  输出1的原因是没有var 的变量不能提升 还是会去找全局中的a
    //     a=2;
    //     var b = 4;
    //     console.log(a, b);// 2 3  a是一个全局的变量 在函数中 我们修改了 a的值
    //                       // 在函数外部访问时 a 的值也会发生改变
    // }
    // f();
    // console.log(a);// 2
    // console.log(b); // erro 全局作用域中不能访问局部作用域

    // 再做一个：函数的形参，你可以理解成是函数内部定义的局部变量
    // function f(x,y) {
    //     res = x + y;
    //     return res;
    // }
    // var r = f(1,2);
    // console.log(r);
    // console.log(x);
    // console.log(y);
    // console.log(res);

    // function f(x,y) {
    //     res = x + y;//res 是一个全局变量 在函数外面是可以访问的
    //     return res;
    // }
    // var r = f(1,2);
    // console.log(r);
    // console.log(res);

//     5，使用变量的好习惯？
//     1，避免使用全局变量
//     解决办法是：最好不要使用没有var 的变量
//     2，当你想定义多个变量，用一个var 时，将var写在代码段第一行，多个变量使用一个var.
//        var
//            a = 1,
//            b = 2,
//            c = 3,
//            d;



    // 创建函数常见的两种方式？以及函数的参数类型？
    // 函数声明和函数表达式
    //函数声明
    // function f() {}
    //
    // //函数表达式
    // var g = function () {
    //     console.log(234);
    // };
    // g();

    // 函数参数类型：形参与实参
    // 函数声明
    // function f1(x, y) {//x, y 形参 看做函数的局部变量
    //     return x + y;
    // }
    // var res = f(1,2);//实参 函数调用的过程就是实参向形参赋值的过程
    // console.log(res);


    // var x = [1,2];
    // function f2(a) {
    //     a[0] = [1,2,3];
    //     a = [1,2,3];
    // }
    // f2(x);
    // console.log(x);
    //输出
    //0: (3) [1, 2, 3]
    //1: 2

    // 1，函数的形参可以看作是函数体中声明的局部变量
    // 2，所有的传递都是传递的栈区中的值。
    // 3，对于基本数据类型，是把真正的数据复制一份，传递给形参。
    // 4，对于引用数据类型，传递的是堆区的地址。

    // 理解arguments对象
    // 是函数内部的属性，只能在函数内部使用，不能在函数外部使用
    // arguments表示当前函数调用时，传递给函数的实参。换句话说，是把所有的实参收集起来，放到了arguments当中。
    // function f(x,y,z) {
    //     console.log(arguments);
    // }
    // f(1,2,3);
    //
    // // 只要一调用函数，内部就会自动有一个arguments属性，这个属性保存着本次调用所传递过来的实际参数。
    // function f1(x,y,z) {
    //     console.log(arguments);
    // }
    // f(1,3,4);
    // f(4,5,7)
    //
    // // arguments对象的应用
    // // (1)求最小值，最大值
    // function f2(x,y,z) {
    //     console.log(arguments);
    // }
    // f(1,3,4);
    //求最大值
    // function f3(x,y,z) {
    //     var a = arguments[0];
    //     for (var i = 0; i<arguments.length;i++){
    //         if (arguments[i]>a){
    //             a = arguments[i];
    //         } else{
    //
    //         }
    //     }
    //     console.log(a);
    // }
    // f3(1,3,34,55,234,2,66)
    // function f3(x,y,z) {
    //     var a = arguments[0];
    //     for (var i = 0; i<arguments.length;i++){
    //         if (arguments[i]<a){
    //             a = arguments[i];
    //         } else{
    //
    //         }
    //     }
    //     console.log(a);
    // }
    // f3(1,3,34,55,234,2,66)

// （2）累加
//     function f() {
//         var sum = 0;
//         for (var i=0; i<arguments.length; i++ ){
//             sum += arguments[i];
//         }
//         return sum;
//     }
//
//     console.log(f(1, 4, 5, 6));


    // 如果你改变了形参，那么arguments对应值是否改变？
    // 结论：当你的形参改变时，那么arguments对应的值也改变
    // function f(x,y) {
    //     console.log(x);
    //     console.log(y);
    //     x = 324;
    //     console.log(arguments[0]);
    //     console.log(y);
    // }
    // f(1,5)
    // 综上所述：当形参列表（x, y）与arguments(arguments[0], arguments[1])之间存在一一对应关系时，一个被修改，另一个也会发生变化。

    // 当形参列表与aguments之间没有对应关系时，一个修改，另一个不会变化
    // function f1(x,y) {
    //     console.log(x);
    //     console.log(y);
    //     arguments[100] = 3424;
    //     console.log(x);
    //     console.log(y);
    // }
    // f1(2,6)

    // 1，在定义函数时，如果这个参数起到关键性的说明作用，那么你最好把它写上去。
    // 2，当参数的个数不确定，类型不确定，需要在程序中动态获得时，可以不写参数。


    //     1,深入变量
    //     a，加var的变量与不加var的变量区别：
    //     •	加var可以作全局变量也可以作局部变量，不加var的只能作全局变量。
    //     •	加var不能被删除，不加var的可以被删除
    // •	加var的能提升，不加var的不能提升
    //     b，变量的作用域
    // •	全局作用域，最外层的函数外面一般是全局作用域
    // •	局部作用域，函数内部一般是局部作用域
    // •	JS中没有块级作用域，在其它编程语言，{}可以划分块级作用域
    //     c，如何确定函数内部变量的值，如果当前函数内部没有定义局部变量，
    //     就去定义这个函数的作用            域中去找那个变量。
    //
    // 2，函数深入
    //     a，创建函数有两种方式：函数声明和函数表达式
    //     b，函数参数的类型有两种：形参与实参
    //     c，函数调用分两个过程：一个是实参向形参赋值的过程，一个是执行函数体的过程
    //     d，函数的参数传送分两种：一个基本数据类型的参数传递，
    //     一个是引用数据类型的参数传递，它              们传递的都是栈区中的值。
    // e，一个函数作为另一个函数的参数
    //     f，arguments对象：当函数调用时，会在函数内部产生一个arguments对象，
    //     这个对象收集了所有的实参，我们可以直接使用arguments[下标]来使用实参。



    // 函数返回多个值
    // return
    //求最大值
    // function f(x,y) {
    //     var max = x >y? x:y;
    //     return max;
    // }
    //
    // console.log(f(3, 56));
    // //求最小值
    // function f2(x,y) {
    //     var min = x<y? x:y;
    //     return  min;
    // }
    //
    // console.log(f(2, 65));
    //
    // function f3(x,y) {
    //     var avg = (x + y)/2;
    //     return avg;
    // }
    //
    // console.log(f(2, 6));

    // 我们可以返回一个数组，在数组中保存着最大值，最小值，平均值：
    // function f(x,y) {
    //     var min = x<y? x:y;
    //     return min;
    //
    //
    //     var max = x>y? x:y;
    //     return max;
    //
    //     var avg = (x+y)/2;
    //     return avg;
    // }
    //
    // console.log(f(2, 5));
    // // 使用对象，我们的把一个对象返回：
    // function f2(x,y) {
    //     var obj = {};
    //     var max = x > y? x:y;
    //     obj.max = max;
    //     var min = x<y? x:y;
    //     obj.min = min;
    // }
    // var o = f(30,5);
    // console.log(o.max);
    // console.log(o.min);
    // console.log(o.avg);

    // 函数是不能返回多个值，只能返回一值（这个值也可以是数组或对象），如果你没有给它返回值，默认返回undefinted。如果我们想当我们调用一个函数时，让它返回多个数据，那么我们可以在函数内部去声明一个数组或对象，把多个值保存到数组或对象中，最后把数据或对象返回。

    // 六，执行上下文
//     2，什么是执行上下文
//     1，函数代码与全局代码
//     一个函数我们就叫它为函数代码，当我们打开我们页面后，一上来就执行的代码，我们叫它为全局代码。全局代码只有一份，局部代码可能有很多，因为函数可能有很多。
//
// 2，全局执行上下文，函数的执行上下文
//     当执行一个函数代码时，就会产生一个函数的执行上下文，执行全局代码时，就会产生一个全局的执行上下文。
// 全局的执行上下文只能有一个，函数的（局部的）执行上下文可能有多个。
//
// 3，每执行一个函数，就产生一个函数执行上下文，执行100函数，就产生100个执行上下文件。
//
// 4，同一个函数，如果你执行了一次，那么就产生一个执行上下文，如果你调用了100次，那么就产生100个执行上下文。
//
// 5，执行上下文的作用：
// 函数在执行的过程中，需要的一切数据都由执行上下文来提供。数据包括：变量与函数。
//
// 6，程序刚开始会进入到全局的执行上下文。

//     栈：
// 在计算机中，栈是一种数据结构，这种数据结构描述了操作数据的一方式。
// 先进后出
//
//     队列：
// 先进先出



    // 5，执行上下文的作用：
// 函数在执行的过程中，需要的一切数据都由执行上下文来提供。数据包括：变量与函数。


//     分析 ：
// 当全局代码一执行，就会产生一个全局的执行上下文(Anonymous),此时这个全局的执行上下文处于栈最下最。
// 当调用ff()函数时，就会产生一个ff的函数执行上下文，这个执行上下文会放到全局执行上下文的上面，也就是说它处于栈顶位置。
// 当在ff函数中，调用f()函数时，也会会产生一个f的函数执行上下文，这个执行上下文会放到ff执行上下文的上面,那么此时，f就牌栈顶位置。
//
// 出栈和入栈：
// 前面我们所演示的就是入栈的操作，就是全局的先入栈，然后是ff入栈，再然后是f入栈。何时出栈尼？

    // f先出栈：
    // ff出栈：一旦执行上下文出栈了，就意味着这个函数需要的数据就被回收。
    // var a = 1;
    // function f3() {
    //     console.log("f");
    // }
    // function f4() {
    //     console.log("ff");
    //     f3();
    // }
    //
    // f4();
    // var b = 2;
    // 执行上下文的作用
    // 作用：提供代码运行时所需要要的各个数据的值。


    // 什么是父级函数？
// 在定义一个函数时，直接把这个函数包起来的那个函数就是父级函数，如果这个函数外面没有函数，那么它的父级函数就是全局代码。
//     function f() {//父级函数 全局代码
//         function f2() {//子函数
//
//         }
//     }

    // 总结：
// 函数执行上下文中保存的数据有两部分组成：1，是自已函数内部定义的变量，函数，arguments， 2，它的父级函数的执行上下文。
// 全局执行上下文件中保存的数据只有一部分：在全局中定义的变量和函数。

// 先在自己的内部去找，如果找到了，就用自己的，如果找不到，就去它的父级函数的执行上下文中去找，如果找到就用它父级的，如果找到不到，就报错。

    // function f2() {
    //     var a = 110;
    // }
    // f2();
    // console.log(a);//找不到全局白能量a 报错


    // 七，函数的嵌套定义
    // 1，JS中没有函数重载
    //后面的函数会覆盖前面的函数

    // 2，作用域链
    // 由于函数内部又定义了函数，所以它势必要形成一个上下文从里到外的引用关系，那么这个引用关系也可以叫做作用域链，如下图所示：

    // 一个函数是为了完成某些功能，功能肯定有大的功能，也有小的功能，对于小的功能，可能一个函数就搞定了，对于大的功能，有可能一个函数搞不定。一个函数搞不定，那么我们就需要去定义多个函数，定义多个函数有两个方式：函数的并列，函数的嵌套
    //函数并列
    // function f1() {}
    // function f2() {}
    // function f3() {}
    // // 函数并列坏处：
    // // 可以暴露函数的实现细节，如果写在了外面，可能无法直接使用子函数。
    //
    // //函数嵌套
    // function f() {
    //     function f1() {
    //         function f2() {
    //
    //         }
    //     }
    // }
    // 函数的嵌套的好处：
    // 1，封闭性，定义在g1内部的函数，在g1外面是不能访问的。


    // 把函数作为返回值
    // 当把一个函数给返回了，我们可以通过接收它的那个变量来调用这个函数：
    // function f4() {
    //     var a = 2;
    //     var f1 = function () {
    //         console.log(a);
    //     }
    //     return f1;
    // }
    // var t = f4();
    // t(); //t 就是f1 调用f1 是f1() 所以说也可以用t()来调用f1

    // 总结：
// 1，函数也是一种数据类型，函数也是一个对象，对象是引用类型。
// 2，var a = 它的后面可以存储任意数据类型。
//     var  a = 1;
//     var a = true;
//     var a = "hello";
//     var a = []
//     var a = {}
//     var a = null
//     var a = function (n) {
//
//     }
    //     3，function f(){};函数声明   var f = function(){}函数表达式。对于函数声明，我们也可以这样认为：function f(){}  定义了一个变量名字叫f, 值是一个函数体。
    // 4，函数调用： 函数名（）;
    //     5，在函数中，当你返回了一个函数时，那么返回的是函数的名字，说白了，就是返回了一个栈区的地址，那么这个地址是指向堆区的具体函数。
    // 6，对于函数的嵌套，我们主是把嵌套的函数给返回了，返回完，主要是在外面使用它。



// IIFE 立即执行函数

//     在实际开发中，我们会与其它人一起写代码，那么就会有一个问题：你的代码中用到变量或函数名，可能与其它人的代码冲突。如何解决冲突？
// 第一种方案：把你写的代码放到一个函数内，然后，去调用这个函数。函数可以划分作用域。也就就，你定义的这个函数中的变量，函数名，函数外面是不能访问的。所以就不会覆盖另人代码中的变量，专业的说是不会污染全局变量。

    // 我们知道，js中有一个alert(), 我们能不能写一个alert(), 这两个alert()函数互不影响：
    // 当我们写一个alert()函数时，那么系统的alert()函数不能用了
//     function alert() {
//         console.log(123);
//     }
//     alert(234);
//
//     // 怎么解决：将我们的自己写的alert函数放到另一个函数中
//     function f() {
//         var a = 1;
//
//         function alert() {
//             console.log(123);
//         }
//         alert();
//     }
//     f();
//     alert(23);
//
//     // 问题又来了：如何最外面的函数f也冲突了，怎么办？
// // 解决办法：立即执行函数表达式。
//
//     // 立即执行的函数表达式三种实现方式
//     // var f = function(){}  这里的function是一个表达式， funciton (){},此时这个function(){}是没有放到赋值运算符的右边，它不是一个表达式，它是一个语句。 是一个声明函数的语句。既然它是一个语句，语句后不能加（）; 如何去修改呢？
//
//      // 1.方式1
//      // function(){}）()
//     (function f() {
//         console.log(345);
//     })();
//
//     // 方式2
//     // （function () {}()）
//     (function () {
//         console.log(23432);
//     }());
//
//     //方式3
//     // +function () {}()
//     // -function () {}()
//     // !function () {}()
//
//     +function () {
//         console.log(556);
//     }();
//     -function () {
//         console.log(23423);
//     }();
//     !function () {
//         console.log(42323);
//     }()
//
//     // JQ中
//     (function () {
//
//     })();
    // 还有一个知识点：
// 带参数的立即调用函数表达式：
//     (function(形参)){}(参数)；
// var f = (function (x) {
//     return x;
// })(5);
//     console.log(f);

    // 综上所述：立即调用函数表达式，可以模拟块级作用域，
    // 解决冲突（变量或函数名），而不会去污染全局变量。
    // 注意的问题： 最后加一定要加分号（;）

    // 闭包
    // 1，什么是闭包？
    // 理解闭包：
// 如果一个函数f内部定义了一个新的函数g, 并且这个函数g中引用了函数f中的变量，那么就称这个函数g是一个闭包。

    // function f1() {
    //     var a = 110;
    //     function f2() {
    //         a += 1;
    //         console.log(a);
    //     }
    //     g();
    // }
    // f();
    //
    // // 如果函数g没有引用函数f中的变量，那么这个函数g不能称为闭包：
    // function f() {
    //     var a = 234;
    //     function n() {
    //         console.log(3532);
    //     }
    // }
    // // 闭包的好处？ 延长变量的生命周期
    // // 我们前面说过：函数外面是不能访问函数里面的变量，但是闭包可以提供访问函数里面变量的机制。
    // // 使用闭包： 我们使用闭包可以在函数外部去访问函数内部的变量
    // function f2() {
    //     var a =234;
    //     function n() {
    //         console.log(a);
    //     }
    //     return n;
    // }
    // var t = f2()
    // t();

    // 当一个函数调用完之后，那么这个函数中的变量就要被销毁。闭包可以去延长一个变量的生命周期。


    // 闭包的坏处？ 会造成内存泄漏。

    //     1，执行上下文：JS代码分两种，全局代码，函数代码。
    //     当执行全局代码时就会产生全局的执行上下文，当执行函数代码时，就会产生函数的执行上下文。
    // 2，执行上下文的作用：在代码执行过程中，需要的所有数据都有执行上下文提供。数据：变量和函数。
    // 3，执行上下文件栈：入栈（函数调用），出栈（函数调用完）
    // 4，执行上下文的组成部分：
    // 函数的执行上下文：本函数内部的变量，函数，arguments  +  父级函数的上下文
    //     全局执行上下文：只有全局的变量和函数组成
    //     5，函数的嵌套会形成一个作用域链
    //     6，函数嵌套的原因：封闭性
    //     7，函数是可以作为返回值
    //     8，立即调用函数表达式IIFE， 原因：解决冲突，防止污染。
    // 9，(function(){})(),   (function(){}()),   +/-/!funciton(){}()
    //     10，闭包：如果一个函数A中，有另一个函数B，B引用了A中的变量，那么就称B是一个闭包。
    // 11，闭包的好处：延长变量的生命周期，不好的地方：造成了内存泄露。


//递归
//     程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
// 直白的说，就是函数在它内部调用了它自己，我们也称为递归函数。

//     function f3() {
//         console.log(234);
//         f3();
//     }
//     f3();
//
//
// // （1）求100累加？
// //     使用传统的方法：
// function f4(n) {
//     var sum = 0;
//     for (var i = 0; i<=n; i++){
//         sum += i;
//     }
//     return sum;
// }
//
//     console.log(f4(100));

    // 使用递归：
// 使用递归时，一个要设置个结束条件，让它归，如果没有结果条件，就出错了：
//     function f5(n) {
//         if (1 === n){
//             return 1;
//         }
//         return f5(n-1)+n;
//     }
//
//     console.log(f5(100));//记得打印

    //运用递归 斐波那契数列
    function getResult(n) {
        if (n==1 || n==2){
            return  1;
        } else{
            return getResult(n-1) + getResult(n-2);
        }
    }

    console.log(getResult(10));
</script>
</html>