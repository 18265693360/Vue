<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
作用 匹配 验证
</body>
<script>
    // 1，正则表达式是一个字符串。它表示了一种规则。
    // 2，正则表达式有它自己特定的语法。
    // 3，它有两个主要的功能：验证，匹配。

    // （2），正则表达式的作用
    // 验证：
    // 比如说当你注册一个网站时，有的网站让提供手机号，
    // 邮箱，性名，身份证号.....等等， 这些操作就是验证。

    // 匹配：
    // 把一个字符串中，我们想要的一部分找出来。如：”今天是2017年4月22号...”

    // 有两种方式去创建一个正则表达式：
    // •	1，使用new
    // •	2，字面量

    // 1 使用 new
    // var a = new RegExp("b");//正则表达式的引用
    // console.log(a);
    // //字面量
    // var str = "hello";
    // var p = /a/; //字面量创建正则表达式 / 定界符
    // console.log(p);

    //  4，正则表达式的使用
    //   正则表达式是一个对象，这个对象中常见的有三个方法：
    //   compile(), exec(), test(); 其中complile用的不多，
    //   test()它是用来验证，exec()是用来匹配的。我们先学习test()。
    // test的用法：
    // 正则表达式.test(字符串);   如果验证成功就返回true, 否则返回false。

    // 正则表达式的使用
    // 三个方法
    // test()用来验证   compile()  exec()用来匹配
    // test的用法
    // 正则表达式.test（字符串） 成功返回true  否则false


    // （1），正则表达式的组成
    // 三个组成部分：
    // •	原子： 必选，不能少。 最基本的组成单位。
    // •	元字符： 可选， 用来修饰原子。
    // •	模式修正符：可选，共有三个  i ,  g,  m
    //模式修正符
    // I：忽略大小写
    // G：全局匹配
    // M：多行匹配

    //     （3），原子
    //     最基本的组成单位，不能少。
    //     按照原子的表现能力，可以为分两类：
    //     •	１，只能表示一个字符的原子
    //     •	２，可以表示一类字符的原子

    // var p = /a/i;
    // var str = "Abc";
    // var res = p.test(str);
    // console.log(res);

    // １，只能表示一个字符的原子
    // 例如：大小写字母，数据，下划线，符号．．．．
    // var p = /1/;
    // var p = /a/;
    // var p = /b/;
    // var p = /_/;
    // var p = /..._/;
    // var str = "qagewg";
    // var str = "3241234";
    // var str = "___...3241234";//false
    // var res = p.test(str);
    // console.log(res);//false


    // ２，可以表示一类字符的原子
    //  \d 表示十进制的数字【0-9】，只要包含数字就是true
    // var p = /\d/;
    // var str = "12343vdsfv _=";
    // var res = p.test(str);
    // console.log(res);

    // \D 表示只要包含非数字就是true
    // var p = /\D/;
    // var str = "412._"; //true
    // var str = "412";//false
    // var res = p.test(str);
    // console.log(res);

    // \s  表示空白字符（空格， tab,  回车键）只要有空白就是true
    // var p = /\s/;
    // var str = "    " + " ";  true
    // var str = "wgewegew"   //false
    // var str = "  "; //true
    // var res = p.test(str);
    // console.log(res);

    // \S  表示非空白字符（空格， tab,  回车键）  只要有非空白就是			true
    // var p = /\S/;
    // var str = "abc" true
    // var str = " " false
    // var str = " g"true
    // var res = p.test(str);
    // console.log(res);

    // \w  表示一个字 0~9  a~z  A~Z  _
    // var p = /\w/;
    // var str = " *";//false
    // var str = " _";//true
    // var res = p.test(str);
    // console.log(res);

    // \W  表示除了 0~9  a~z  A~Z  _  以外的字符
    // var p = /\W/;
    // var str = "&"; true
    // var str = "2";//false
    // var res = p.test(str);
    // console.log(res);

    // •	1，对于test()来说，只是检测有还是没有。 不管字符串中的个数。
    // •	2，对于test()来说，不管字符出现在字符串中什么位置。
    // •	3，对于test()来说，正则中的字符串顺序要与字符串中子串的顺序一致。
    // •	4，使用模式修正符，可以不考虑大小写问题。


    // 元字符的分类

    // 开始元字符和结束元字符
    // 数量相关的元字符
    // 逻辑相关的元字符
    // 转义符
    // 分组组合

    // 2，开始元字符 ^ 与 结束元字符 $
    // var p = /^\d/; // ^元字符是用来修饰原子   \d字符串必须以数字开头为true
    // var str = "2431";//true
    // var str = "a2431";//false
    // var str = "_(a2431";//false
    // var res = p.test(str);
    // console.log(res);

    // 结束元字符： $
    // 出现位置：一般是在正则表达式的最后面出现
    // 作用：表示必须要以它前面紧贴的那个原子作为结束
    // 代码如下：
    // var p = /4$/;
    // // var str = "23f3234v4";//true
    // var str = "23f3234v4wer";//false
    // var res = p.test(str);
    // console.log(res);

    // var p = /^\d\d\d$/; //表示字符串中有3个原子 这3个原子都必须是数字
    // var p = /^\d\d\d/; //表示字符串以数字打头 第一个数字后面接2数字
    // var str = "1234567890121"; false
    // var str = "123";//true
    // var res = p.test(str);
    // console.log(res);

    // var p = /^gds/;//表示以g开头 后面紧挨着ds
    // var p = /^gds$/;//表示以g开头 后面必须是gds
    // var str = "gdssdf";
    // var str = "gds";//true
    // var res = p.test(str);
    // console.log(res);


    // 3，数量相关的元字符 {}  *  +  ？
    // {m}   前面的原子必须要出现m次。
    // var p = /\d{3}/;//表示前面的数字（也就是原子要出现3次）
    // var str = "132";//true
    // var res = p.test(str);
    // console.log(res);

    // {m,n}  :  前面的原子必须至少要出现m次，最多出现n次。
    // var p = /\d{5,8}/;//但其实最多出现次数不一定可以无限多
    // var str = "2343";
    // var res = p.test(str);
    // console.log(res);

    // {m,}  :  前面的原子必须至少要出现m次，最多不限
    // var p = /\d{3,}/;
    // var str = "42";//false
    // var str = "42w4r23423";//true
    // var res = p.test(str);
    // console.log(res);

    //字母a 后面要跟上数字 并且有两个
    // var p = /a\d{2}/;
    // var str = "a32345345";
    // var res = p.test(str);
    // console.log(res);

    // *  :  前面的原子可以出现0次或很多次  相当于{0,}
    // 检测字符串中是否有生日的子串
    // var p = /\d*/;
    // var str = "你的生日是2019-3-3";
    // var res = p.test(str);
    // console.log(res);

    // +  :  前面的原子至少出现1次  相当于{1,}
    // var p = /\d+/;
    // var str = "你的生日实施2019-23-53";
    // var res = p.test(str);
    // console.log(res);


    // ?  :  前面的原子至少出现0次 或者是1次  相当于{0，1}
    // var p = /生\d?/;
    // var p = /婷\d?/;//false
    // var str = "你的生日是1234";
    // var res = p.test(str);
    // console.log(res);

 //    1，什么是正则表达式？
 //    a， 正则表达式就是带着某种规则的字符串，只是它是一个特殊的字符串。
 //    b， 正则表达式有它自己的语法
 //    c， 正则表达式的功能是用来进行验证与匹配和替换
 //    2，正则表达式有什么作用？
 //    功能是用来进行验证与匹配


    // 4，逻辑相关的元字符 [ ]  |
    // []  ： 表示多个原子，只要有一个在目标字符串中出现就行。
    // var p = /[ewv s]/;
    // var str = "w";
    // var res = p.test(str);
    // console.log(res);

    // 在［］中还可以使用两个额外的符号：　＾　-
    // •	^ 表示取反
    // 下面的写法，是什么意思 ？下面的写法是错误的，我们一定不能将^写在原子中间，只能写在开头。
    // •	- 表示区间
    // var p = /[^av]/;
    // var str = "a";//false
    // var str = "ehr";//true
    // var res = p.test(str);
    // console.log(res);

    // var p = /[0-3]/;
    // var str = "5";//false
    // var res = p.test(str);
    // console.log(res);

//     说明：对于 /abc|def/ 表示或者abc, 或者是def，或者是abcef, 或者abdef
//     注意下面的区别：
//     /cat|dog/  表示：cat 或 dog 或catog 或 cadog
//     /[catdog]/  表示：对于里面的6个字符出一个就行
//     /catdog/  表示：六个字符都必须出现，顺序也不变
//     var p = /abc|def/;//或
//     var str = "abc";
//     var res = p.test(str);
//     console.log(res);


    // 5，转义符 \
    // 我们前面学习了很多的元字符 $  ^  {}  []  ?  *  | 等等，当你想要这些元字符当作一个普通的原子使用时，这个时候你需要用到转义符 /
    // var p = /\$/;
    // var p = /\^/;
    // var p = /$/;
    // var str = "^";//true
    // var str = "2tewrt";//false
    // var str = "$";//true
    // var res = p.test(str);
    // console.log(res);


    // 6，分组组合 （）
    // 它可以把多个原子组合成一个大原子。
    // /abc+/  表示ab后面加1个以上的c, 代码如下：
    // var p = /abc+/;
    // var str = "abccccc";
    // var res = p.test(str);
    // console.log(res);

    // /（abc）+/  表示abc这个整体要出现一次以上：
    // var p = /(abc)+/;
    // var str = "abcabcabcacbbabc";
    // var res = p.test(str)
    // console.log(res);

    // var p = /[(ab)(ce)]/;
    // var str = "a";
    // var res = p.test(str);
    // console.log(res);

//     1， $ 如果它出在正则表达式的最后，表示以它紧挨着前面的原子结尾。
    //     如果想看一个目标字符串中没有没$本身。 要使用转义后的：\$
//     2， ^ 如果它出在正则表达式的最前面，表示以它紧挨着后面的原子作为开始。
    //     看一个目标字符串中没有没^本身。 要使用转义后的：\^
//     3，+ 表示前面的原子要连续的出现1次或多次，看一个目标字符串中没有没+本身。
    //     要使用转义后的：\+
//     4， * 表示前面的原子要连续的出现0次或多次，看一个目标字符串中没有没*本身。
    //         要使用转义后的：\*
//     5， ？示前面的原子要的出现0次或1次，看一个目标字符串中没有没？本身。 要使用转义后的：\？
//     6，[] 表示一个原子表的开始与结束， 看一个目标字符串中没有没[, ]本身。 要使用转义后的：\[   \]
//     7，() 表示分组， ()里面的内容我们可以叫它为子表达式，
    //     []里面的内容我们只可以叫它为原子表。()表示子表达式的开始与结束。
    //     看一个目标字符串中没有没（, ）本身。 要使用转义后的：\（   \）
//     8，| 指两项之间的选择。看一个目标字符串中没有没|本身。 要使用转义后的：\|
//     9，{} 表示数量相关的一个元字符，   看一个目标字符串中没有没{}本身。 要使用转义后的：\{   \}
//     10， 看一个目标字符串中没有没\本身。 要使用转义后的：\\

    // 编写一个正则表达式的流程
    // 1，分析：把正确的与错误的列举出来
    // 2，提炼：把规则提出来
    // 3，书写：用原子与元字符来组合，表达第2步中的规则。

    // 手机号码验证
    // 第一步：分析
    // 正确：17001100482， 13312345678......
    // 错误：01234321445,   a123445342....
    // 第二步：提炼
    // 1，必须是数字
    // 2，必须是11位
    // 3，必须是1打头
    // 4，第二位必须是3，4，5，6，7，8
    // 5，必须是数字结尾
    // 第三步：书写：
    // var p = /^1[3-8]\d{9}$/;
    // var str = "18332720136";
    // var res = p.test(str);
    // console.log(res);

    // （3），身份证号验证
    // 第一步：分析
    // 正确：410883198904156553 .....
    // 错误：a345678956789  1234  234567893456789034567894567
    //
    // 第二步：提炼
    // 1，必须是18位
    // 2，以数字开头
    // 3，前17位必须是数字
    // 4，最后一位可能是数字也可能是X
    // 5，第7位必须是1或2
    // 6，第11位必须是0或1
    // 7，第13位必须是0或1，或2，或3
    //
    // 第三步：书写
    // var p = /^\d{6}[1-2]\d{3}[0-1]\d[0-3]\d{4}[\d|X]$/;
    // var str = "103521199403233511";
    // var res = p.test(str);
    // console.log(res);

    //     （5），电子邮箱验证
    //     第一步分析：
    // 正确：	2345@qq.com   abc@sina.cn  6789@163.com  _45678@qq.net
    //     错误：  234qq.com  sdf@.com  2345.com
    //
    //     第二步提炼：
    // 1，在@前面必须有内容
    //     2，只能有一个@
    //         3，有一个.  并且这个.要出现在@的后面
    //     4，所有字符都必须是0-1， a-z,  A-Z, _  --->  \w
    //     5，@和. 之间必须要有至少要有2个以上的数字，或字母（不分大小写）
    // 6，.后面有2个以上的大小字母
    // var p = /^[A-Z|a-z|0-9]+@[0-9|a-z|A-Z]{2,5}\.[a-z|A-Z]{2,4}$/;
    // var str = "liu233511@163.com";
    // var res = p.test(str);
    // console.log(res);

    // var reg = /^[A-Z|a-z|0-9]+@[A-Z|a-z|0-9]{2,5}\.[A-Z|a-z]{2,4}$/;
    // var str = "646617513@qq.com";
    // console.log(reg.test(str));

    // 十六进制颜色
    // #ffffff #1af
    // 1.必须以#开头
    // 2.#后可能接6个位或者3位
    // 3.#号后的字的取值范围为0-9 a-f(A-F);

    // var p = /{^#[0-9a-f]{6}$}|{^#[0-9a-f]{3}$}/i;//不分大小写
    // var str = "#ff0";
    // var res = p.test(str);
    // console.log(res);

    // exec exec()是用来匹配的
    // exec()
    // 返回值 = 正则表达式.exec(目标字符串)
    // 返回值
    // 如果找到，就返回数组
    // 如果找不到就返回 null
    // 功能 在字符串中找出符合正则表达式的字符串
    // var p = /a/;
    // var str = "abcdefgabc";
    // var res = p.exec(str);
    // console.log(res);
    // 如果找到所有呢？  模式修正符g   全局匹配！
    // var p = /A/ig;
    // var str = "abcdefgabc";
    // var res = p.exec(str);
    // console.log(res);

    // var p = /[1-9]\d*/g;
    // var str = "今年18了，身高180";
    // var res = p.exec(str);
    // console.log(res);

    // 如果目标字符串中有多个符号要求的子串，我们需要写多份结果：
    // var p = /[1-9]\d*/g;
    // var str =  "今年18，身高183 ！体重75";
    // var res = p.exec(str);
    // console.log(res);
    //
    // var res = p.exec(str);
    // console.log(res);
    //
    // var res = p.exec(str);
    // console.log(res);

    // 如果我们不知道，目标字符串中有多少个符合要求？ 怎么做？
    // 用while
    // var p = /[1-9]\d*/g;
    // var str = "今年18 身高183 体重75";
    //
    // var res;
    // while (res = p.exec(str)){
    //     console.log(res);
    // }

    // var p = /\d{4}-\d{2}-\d{2}/g;
    // var str = "你2019-03-12； 我2019-02-11；他2019-03-15";
    // var res;
    // while (res = p.exec(str)){
    //     console.log(res);
    // }

    // （2）分组引用 （）

    //未分组
    // var p = /\d{4}-\d{2}-\d{2}/g;
    // var str = "你1919-01-12,我1019-12-21，他2019-01-31";
    // var res;
    // while (res = p.exec(str)){
    //     console.log(res);
    // }

    //使用分组 （）
    // var p = /(\d{4})-(\d{2})-(\d{2})/g;
    // var str = "你1919-01-12,我1019-12-21，他2019-01-31";
    // var res;
    // while (res = p.exec(str)){
    //     console.log(res);
    // }
    // (4) ["1919-01-12", "1919", "01", "12", index: 1, input: "你1919-01-12,我1019-12-21，他2019-01-31", groups: undefined]
    //  ["1019-12-21", "1019", "12", "21", index: 13, input: "你1919-01-12,我1019-12-21，他2019-01-31", groups: undefined]
    // (4) ["2019-01-31", "2019", "01", "31", index: 25, input: "你1919-01-12,我1019-12-21，他2019-01-31", groups: undefined]

    // 向后引用 寻找1 2位 和 末尾两位一样的
    // var p = /(\d)(\d)\d\2\1/g;
    // var str = "12321 23432 45653 67828 12341 45618 78987";
    // var res;
    // while (res = p.exec(str)){
    //     console.log(res);
    // }
    //     ["12321", "1", "2", index: 0,
    //     (3) ["23432", "2", "3", index: 6,
    //     ["78987", "7", "8", index: 36,

    // （4）取消分组引用
    // 分组引用需要额外的空间来存储。当我们只是需要分组，不需要引用时，可以取消引用。
    // 做法：在()里面前加上 ？:
    // var p = /(?:\d{4})-(\d{2})-(\d{2})/g;
    // var str = "你1919-01-12,我1019-12-21，他2019-01-31"
    // var res;
    // while (res = p.exec(str)){
    //     console.log(res);
    // }
   //  ["1919-01-12", "01", "12", index:
   //  ["1019-12-21", "12", "21", index:
   //  ["2019-01-31", "01", "31", index:

    // 贪婪模式与惰性模式
    // 1贪婪模式
    // 贪婪模式：匹配尽可能多的字符
    // 当匹配到字符有多有少时，首先匹配多的。
    // var p = /a[a-b0-9]*b/;
    // var str = "1a123ba123ba123";
    // var res = p.exec(str);
    // console.log(res);
    // 因为这里面有个*， 所以才会存在贪婪模式。思考？除了* ，哪些还有贪婪模式：
    // *    +   ？  {}

    // 堕性模式
    // 尽可能少的去匹配，默认是贪婪模式，如何变成惰性模式？需要在重复内容的后面加上？
    // var p = /a[a-b0-9]*?b/;
    // var str = "0a1b23ba123ba123";
    // var res = p.exec(str);
    // console.log(res);

    // 正则表达式
    // （1）复习replace方法
    // replace这个方法的作用：替换。
    // var str = "hello world";
    // var res = str.replace('hello','米猪头');
    // console.log(res);


    // replace方法第一个参数可以使用正则：
    // 1919换成2019
    // var str = "你1919-01-12,我1019-12-21，他2019-01-31"
    // var res = str.replace(/1919/g,"2019");
    // console.log(res);


    // 去除字符串前后的空格，代码如下：
    // var str =  " 北京天气 ";
    // console.log(str);
    // // var res = str.replace(/(^\s+) | (\s+$)/g,""); 或前后不能有空格 不起作用
    // var res = str.replace(/(^\s+)|(\s+$)/g,"");
    // console.log(res);

    // 练习三
    // $1 $2 $3
    // 把匹配到的内容，用分组引用的部分来代替。在正则中第一个（）,对应$1, 第二个（）,就对应$2.....
    // var str = "1989-09-01 1925-02-03 1926-08-03 1928-01-06";
    // var res = str.replace(/(\d{4})-\d{2}-\d{2}/g,"$1年");
    // console.log(res);

    //将所有 - 去除 用年月日
    var str = "1989-09-01 1925-02-03 1926-08-03 1928-01-06"
    var res = str.replace(/(\d{4})-(\d{2})-(\d{2})/g, "$1年$2月$3日");
    console.log(res);


</script>
</html>